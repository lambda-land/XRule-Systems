


v := \x -> e | n | b

e := v | x | let x = e in e | letrec x = e in e | e e | e op e



e => v' = eval e     [v'/x]e' => v = eval ([v'/x]e') = eval ((x ~> v') e')
------------------------------------ 
let x = e in e' => v


-- email begin

rho : e => v'     rho[x -> v'] : e' => v
-----------------------------------------
rho : let x = e in e' => v


e => v'    [v'/x]e' => v
-----------------------------
let x = e in e' => v



e => \z -> e''     [e/x]e' => v
----------------------------------
let x = e in e' => v

-- email end

e => \z -> e''     [e/x]e' => v    Display (e' => v)
----------------------------------
let x = e in e' => v


let f = flip add in e'
let f = \x -> e in e'

e1 => v'      v' = \z -> e'      [x/v']e2 => v
-------------------------------------------------LetAbs
X{ let x = e1 in e2 => v | e2 => v }


e1 => v'         [x/v']e2 => v
----------------------------------------------LetVal
X{ let x = e1 in e2 => v | [x/v']e2 => v }



-----------------------------
X{ rho : e => v | e => v }


eval e = v
e => v

1 + 2 => ?v1    3 + 4 => ?v2            v1 * v2 = 21
----------------------------------------------------
(1 + 2) * (3 + 4) => 21


EvalJ (1 + 2) * (3 + 4) (eval (1 + 2) * (3 + 4))

n < k = f(n,m)       f(n,m) = k < m
------------------
      n < m

f(n,m) = n + 1
f(n,m) = m - 1
f(n,m) = midPoint n m


n < k       k < j      j < i     i < m
---------------------------------------
             n < m


