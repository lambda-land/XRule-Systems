


APP-V
P{e1=>\x.e'}    [v/x]e'=>w
--------------------------
           e1 v=>w

The second rule uses another form of tags "X" that has two judgments: the first is used for the ordinary semantics, and the second will be used in explanations.

APP-X
P{e1=>\x.e'}    (e2 e3)=>v    [v/x]e'=>w
----------------------------------------
           X{e1 e2=>w|e1 v=>w}


show (f (g h)) = "f (g h)" when g h => \x -> ...
show (f (g h)) = "f v" when g h => v

APP-X
P{e1=>\x.e'}    (e2 e3)=>v    [v/x]e'=>w

e2 e3 => v
----------------------------------------
           e1 (e2 e3) => v'




rho : e1 => \x -> e3           -- rho : e2 => v' --           rho[x -> v'] : e3 => v
--------------------------------------------------------------------------------------------
rho : e1 e2 => v



e1 => \x -> e3               
-- e2 => v'          [v'/x]e3 => v
-- [e2/x]e3 => v
--------------------------------------------------------------------------------------------
e1 e2 => v



e2 e3 => v'               e1 v' => v      -- [v'/x]e1 => v
------------------------------------------------------------------------App1
e1 (e2 e3) => v



e1 => \x -> e3                [e2/x]e3 => v
---------------------------------------------App2
e1 e2 => v


funname exp => val
(\y -> ...) exp => val

e1 => v'                   [v'/x]e2 => v
---------------------------------------------
let x = e1 in e2 => v


(\f x y -> f y x) (\a b -> a + b) 1 2 => 3
------------------------------------------
let flip = \f x y -> f y x in flip add 1 2 => 3


(\x y -> add y x) 1 2 => 3
------------------------------------------
let flip = \f x y -> f y x in flip add 1 2 => 3


5 => 5           5 + 2 => 7
----------------------------------------
let x = 5 in x + 2 => 7


rho : x => \_ -> _       x 
------------------------------
rho : x e => v



length => \xs -> e 
tail xs => [2,3,4,5]
[[2,3,4,5]/xs]e => e'
--------------------------------------
1 + length (tail xs) => 5
vvvvvvvvvvvvvvvvvvvvvvvvv
1 + length [2,3,4,5] => 5               tail [1,2,3,4,5] => [2,3,4,5]


length [2,3,4,5] => 4
------------------------------------------------------------
1 + length [2,3,4,5] => 5        tail [1,2,3,4,5] => [2,3,4,5]
--------------------------------------------
1 + length (tail [1,2,3,4,5]) => 5




tail [1,2,3,4,5] => [2,3,4,5]             length [2,3,4,5] => 4
----------------------------------------------------------------
1 + length (tail [1,2,3,4,5]) => 5



...
--------------------------------------
1 + length (tail xs) => 5

rec f . e


data Tag a = Trivial a | Program a | X a | NoTag a


class Functor f => Refine j f where
    tag :: Proof j -> Proof (f j)

instance Refine EvalJ Tag where
    tag :: Proof EvalJ -> Proof (Tag EvalJ)

