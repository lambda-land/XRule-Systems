-- File generated by the BNF Converter (bnfc 2.9.4).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Parser.Skel where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified Parser.Abs

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transTokUnit :: Parser.Abs.TokUnit -> Result
transTokUnit x = case x of
  Parser.Abs.TokUnit string -> failure x

transUIdent :: Parser.Abs.UIdent -> Result
transUIdent x = case x of
  Parser.Abs.UIdent string -> failure x

transPIdent :: Parser.Abs.PIdent -> Result
transPIdent x = case x of
  Parser.Abs.PIdent string -> failure x

transPInteger :: Parser.Abs.PInteger -> Result
transPInteger x = case x of
  Parser.Abs.PInteger string -> failure x

transSCPL :: Parser.Abs.SCPL -> Result
transSCPL x = case x of
  Parser.Abs.SCPLPROG defns -> failure x

transDefn :: Parser.Abs.Defn -> Result
transDefn x = case x of
  Parser.Abs.DEFN pident stmt -> failure x

transStmt :: Parser.Abs.Stmt -> Result
transStmt x = case x of
  Parser.Abs.CASESTMT exp caseterms -> failure x
  Parser.Abs.IFSTMT exp stmt1 stmt2 -> failure x
  Parser.Abs.BARESTMT exp -> failure x
  Parser.Abs.ELet let_ letinstmt stmt -> failure x

transLet :: Parser.Abs.Let -> Result
transLet x = case x of
  Parser.Abs.LET -> failure x
  Parser.Abs.LRec -> failure x

transCaseTerm :: Parser.Abs.CaseTerm -> Result
transCaseTerm x = case x of
  Parser.Abs.CASE_STMT casepattern stmt -> failure x

transLetInStmt :: Parser.Abs.LetInStmt -> Result
transLetInStmt x = case x of
  Parser.Abs.LET_IN_STMT pident exp -> failure x

transType :: Parser.Abs.Type -> Result
transType x = case x of
  Parser.Abs.TYPEARROW typen type_ -> failure x
  Parser.Abs.TYPENext typen -> failure x

transTypeN :: Parser.Abs.TypeN -> Result
transTypeN x = case x of
  Parser.Abs.TYPEUNIT tokunit -> failure x
  Parser.Abs.TYPECONST_VAR uident -> failure x
  Parser.Abs.TYPELIST type_ -> failure x
  Parser.Abs.TYPEPROD types -> failure x
  Parser.Abs.TYPEBRACKET type_ -> failure x
  Parser.Abs.CONST_TYPE constanttype -> failure x

transCasePattern :: Parser.Abs.CasePattern -> Result
transCasePattern x = case x of
  Parser.Abs.TRUE_PATTERN -> failure x
  Parser.Abs.FALSE_PATTERN -> failure x

transExp :: Parser.Abs.Exp -> Result
transExp x = case x of
  Parser.Abs.EInt pinteger -> failure x
  Parser.Abs.ETrue -> failure x
  Parser.Abs.EFalse -> failure x
  Parser.Abs.EVar pident -> failure x
  Parser.Abs.EString string -> failure x
  Parser.Abs.EList exps -> failure x
  Parser.Abs.ECall pident exps -> failure x
  Parser.Abs.ENeg exp -> failure x
  Parser.Abs.CONSTERM exp1 exp2 -> failure x
  Parser.Abs.EAPPEND exp1 exp2 -> failure x
  Parser.Abs.EMul exp1 exp2 -> failure x
  Parser.Abs.EDiv exp1 exp2 -> failure x
  Parser.Abs.EAdd exp1 exp2 -> failure x
  Parser.Abs.ESub exp1 exp2 -> failure x
  Parser.Abs.ELt exp1 exp2 -> failure x
  Parser.Abs.EGt exp1 exp2 -> failure x
  Parser.Abs.ELEq exp1 exp2 -> failure x
  Parser.Abs.EGEq exp1 exp2 -> failure x
  Parser.Abs.EEq exp1 exp2 -> failure x
  Parser.Abs.ENEq exp1 exp2 -> failure x
  Parser.Abs.EAnd exp1 exp2 -> failure x
  Parser.Abs.EOr exp1 exp2 -> failure x
  Parser.Abs.ELambda pidents stmt -> failure x

transTypeAnnotation :: Parser.Abs.TypeAnnotation -> Result
transTypeAnnotation x = case x of
  Parser.Abs.TYPEANNOTATION type_ -> failure x
  Parser.Abs.TYPEANNOTATION_EMPTY -> failure x

transConstantType :: Parser.Abs.ConstantType -> Result
transConstantType x = case x of
  Parser.Abs.INTEGER pinteger -> failure x
  Parser.Abs.STRING string -> failure x
  Parser.Abs.CHAR char -> failure x
  Parser.Abs.DOUBLE double -> failure x
