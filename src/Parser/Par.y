-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Parser.Par
  ( happyError
  , myLexer
  , pSCPL
  , pListDefn
  , pDefn
  , pStmt2
  , pLet
  , pStmt1
  , pCaseTerm
  , pLetInStmt
  , pType
  , pTypeN
  , pListTypeN
  , pListType
  , pListUIdent
  , pCasePattern
  , pListCaseTerm
  , pExp15
  , pExp13
  , pExp12
  , pExp11
  , pExp9
  , pExp8
  , pExp4
  , pExp3
  , pExp1
  , pListPIdent
  , pTypeAnnotation
  , pExp
  , pExp2
  , pExp5
  , pExp6
  , pExp7
  , pExp10
  , pExp14
  , pListExp
  , pConstantType
  ) where

import Prelude

import qualified Parser.Abs
import Parser.Lex

}

%name pSCPL SCPL
%name pListDefn ListDefn
%name pDefn Defn
%name pStmt2 Stmt2
%name pLet Let
%name pStmt1 Stmt1
%name pCaseTerm CaseTerm
%name pLetInStmt LetInStmt
%name pType Type
%name pTypeN TypeN
%name pListTypeN ListTypeN
%name pListType ListType
%name pListUIdent ListUIdent
%name pCasePattern CasePattern
%name pListCaseTerm ListCaseTerm
%name pExp15 Exp15
%name pExp13 Exp13
%name pExp12 Exp12
%name pExp11 Exp11
%name pExp9 Exp9
%name pExp8 Exp8
%name pExp4 Exp4
%name pExp3 Exp3
%name pExp1 Exp1
%name pListPIdent ListPIdent
%name pTypeAnnotation TypeAnnotation
%name pExp Exp
%name pExp2 Exp2
%name pExp5 Exp5
%name pExp6 Exp6
%name pExp7 Exp7
%name pExp10 Exp10
%name pExp14 Exp14
%name pListExp ListExp
%name pConstantType ConstantType
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='       { PT _ (TS _ 1)       }
  '&&'       { PT _ (TS _ 2)       }
  '('        { PT _ (TS _ 3)       }
  ')'        { PT _ (TS _ 4)       }
  '*'        { PT _ (TS _ 5)       }
  '+'        { PT _ (TS _ 6)       }
  '++'       { PT _ (TS _ 7)       }
  ','        { PT _ (TS _ 8)       }
  '-'        { PT _ (TS _ 9)       }
  '->'       { PT _ (TS _ 10)      }
  '/'        { PT _ (TS _ 11)      }
  ':'        { PT _ (TS _ 12)      }
  '::'       { PT _ (TS _ 13)      }
  ';'        { PT _ (TS _ 14)      }
  '<'        { PT _ (TS _ 15)      }
  '<='       { PT _ (TS _ 16)      }
  '='        { PT _ (TS _ 17)      }
  '=='       { PT _ (TS _ 18)      }
  '>'        { PT _ (TS _ 19)      }
  '>='       { PT _ (TS _ 20)      }
  'False'    { PT _ (TS _ 21)      }
  'True'     { PT _ (TS _ 22)      }
  '['        { PT _ (TS _ 23)      }
  '\\'       { PT _ (TS _ 24)      }
  ']'        { PT _ (TS _ 25)      }
  'case'     { PT _ (TS _ 26)      }
  'else'     { PT _ (TS _ 27)      }
  'if'       { PT _ (TS _ 28)      }
  'in'       { PT _ (TS _ 29)      }
  'let'      { PT _ (TS _ 30)      }
  'letrec'   { PT _ (TS _ 31)      }
  'of'       { PT _ (TS _ 32)      }
  'then'     { PT _ (TS _ 33)      }
  '{'        { PT _ (TS _ 34)      }
  '||'       { PT _ (TS _ 35)      }
  '}'        { PT _ (TS _ 36)      }
  L_charac   { PT _ (TC $$)        }
  L_doubl    { PT _ (TD $$)        }
  L_quoted   { PT _ (TL $$)        }
  L_TokUnit  { PT _ (T_TokUnit _)  }
  L_UIdent   { PT _ (T_UIdent _)   }
  L_PIdent   { PT _ (T_PIdent _)   }
  L_PInteger { PT _ (T_PInteger _) }

%%

Char    :: { Char }
Char     : L_charac { (read $1) :: Char }

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

String  :: { String }
String   : L_quoted { $1 }

TokUnit :: { Parser.Abs.TokUnit }
TokUnit  : L_TokUnit { Parser.Abs.TokUnit (mkPosToken $1) }

UIdent :: { Parser.Abs.UIdent }
UIdent  : L_UIdent { Parser.Abs.UIdent (mkPosToken $1) }

PIdent :: { Parser.Abs.PIdent }
PIdent  : L_PIdent { Parser.Abs.PIdent (mkPosToken $1) }

PInteger :: { Parser.Abs.PInteger }
PInteger  : L_PInteger { Parser.Abs.PInteger (mkPosToken $1) }

SCPL :: { Parser.Abs.SCPL }
SCPL : ListDefn { Parser.Abs.SCPLPROG $1 }

ListDefn :: { [Parser.Abs.Defn] }
ListDefn : Defn { (:[]) $1 } | Defn ListDefn { (:) $1 $2 }

Defn :: { Parser.Abs.Defn }
Defn : PIdent '=' Stmt1 { Parser.Abs.DEFN $1 $3 }

Stmt2 :: { Parser.Abs.Stmt }
Stmt2
  : 'case' Exp 'of' '{' ListCaseTerm '}' { Parser.Abs.CASESTMT $2 $5 }
  | 'if' Exp 'then' Stmt2 'else' Stmt2 { Parser.Abs.IFSTMT $2 $4 $6 }
  | Exp { Parser.Abs.BARESTMT $1 }

Let :: { Parser.Abs.Let }
Let : 'let' { Parser.Abs.LET } | 'letrec' { Parser.Abs.LRec }

Stmt1 :: { Parser.Abs.Stmt }
Stmt1
  : Let LetInStmt 'in' Stmt1 { Parser.Abs.ELet $1 $2 $4 }
  | Stmt2 { $1 }

CaseTerm :: { Parser.Abs.CaseTerm }
CaseTerm : CasePattern '->' Stmt1 { Parser.Abs.CASE_STMT $1 $3 }

LetInStmt :: { Parser.Abs.LetInStmt }
LetInStmt : PIdent '=' Exp { Parser.Abs.LET_IN_STMT $1 $3 }

Type :: { Parser.Abs.Type }
Type
  : TypeN '->' Type { Parser.Abs.TYPEARROW $1 $3 }
  | TypeN { Parser.Abs.TYPENext $1 }

TypeN :: { Parser.Abs.TypeN }
TypeN
  : TokUnit { Parser.Abs.TYPEUNIT $1 }
  | UIdent { Parser.Abs.TYPECONST_VAR $1 }
  | '[' Type ']' { Parser.Abs.TYPELIST $2 }
  | '<' ListType '>' { Parser.Abs.TYPEPROD $2 }
  | '(' Type ')' { Parser.Abs.TYPEBRACKET $2 }
  | ConstantType { Parser.Abs.CONST_TYPE $1 }

ListTypeN :: { [Parser.Abs.TypeN] }
ListTypeN
  : {- empty -} { [] }
  | TypeN { (:[]) $1 }
  | TypeN ',' ListTypeN { (:) $1 $3 }

ListType :: { [Parser.Abs.Type] }
ListType : Type { (:[]) $1 } | Type ',' ListType { (:) $1 $3 }

ListUIdent :: { [Parser.Abs.UIdent] }
ListUIdent
  : {- empty -} { [] }
  | UIdent { (:[]) $1 }
  | UIdent ',' ListUIdent { (:) $1 $3 }

CasePattern :: { Parser.Abs.CasePattern }
CasePattern
  : 'True' { Parser.Abs.TRUE_PATTERN }
  | 'False' { Parser.Abs.FALSE_PATTERN }

ListCaseTerm :: { [Parser.Abs.CaseTerm] }
ListCaseTerm
  : CaseTerm { (:[]) $1 } | CaseTerm ';' ListCaseTerm { (:) $1 $3 }

Exp15 :: { Parser.Abs.Exp }
Exp15
  : PInteger { Parser.Abs.EInt $1 }
  | 'True' { Parser.Abs.ETrue }
  | 'False' { Parser.Abs.EFalse }
  | PIdent { Parser.Abs.EVar $1 }
  | String { Parser.Abs.EString $1 }
  | '[' ListExp ']' { Parser.Abs.EList $2 }
  | PIdent '(' ListExp ')' { Parser.Abs.ECall $1 $3 }
  | '(' Exp ')' { $2 }

Exp13 :: { Parser.Abs.Exp }
Exp13
  : '-' Exp14 { Parser.Abs.ENeg $2 }
  | Exp13 ':' Exp14 { Parser.Abs.CONSTERM $1 $3 }
  | Exp14 { $1 }

Exp12 :: { Parser.Abs.Exp }
Exp12
  : Exp12 '++' Exp13 { Parser.Abs.EAPPEND $1 $3 }
  | Exp12 '*' Exp13 { Parser.Abs.EMul $1 $3 }
  | Exp12 '/' Exp13 { Parser.Abs.EDiv $1 $3 }
  | Exp13 { $1 }

Exp11 :: { Parser.Abs.Exp }
Exp11
  : Exp11 '+' Exp12 { Parser.Abs.EAdd $1 $3 }
  | Exp11 '-' Exp12 { Parser.Abs.ESub $1 $3 }
  | Exp12 { $1 }

Exp9 :: { Parser.Abs.Exp }
Exp9
  : Exp9 '<' Exp10 { Parser.Abs.ELt $1 $3 }
  | Exp9 '>' Exp10 { Parser.Abs.EGt $1 $3 }
  | Exp9 '<=' Exp10 { Parser.Abs.ELEq $1 $3 }
  | Exp9 '>=' Exp10 { Parser.Abs.EGEq $1 $3 }
  | Exp10 { $1 }

Exp8 :: { Parser.Abs.Exp }
Exp8
  : Exp8 '==' Exp9 { Parser.Abs.EEq $1 $3 }
  | Exp8 '!=' Exp9 { Parser.Abs.ENEq $1 $3 }
  | Exp9 { $1 }

Exp4 :: { Parser.Abs.Exp }
Exp4 : Exp4 '&&' Exp5 { Parser.Abs.EAnd $1 $3 } | Exp5 { $1 }

Exp3 :: { Parser.Abs.Exp }
Exp3 : Exp3 '||' Exp4 { Parser.Abs.EOr $1 $3 } | Exp4 { $1 }

Exp1 :: { Parser.Abs.Exp }
Exp1
  : '\\' ListPIdent '->' Stmt1 { Parser.Abs.ELambda $2 $4 }
  | Exp2 { $1 }

ListPIdent :: { [Parser.Abs.PIdent] }
ListPIdent : PIdent { (:[]) $1 } | PIdent ListPIdent { (:) $1 $2 }

TypeAnnotation :: { Parser.Abs.TypeAnnotation }
TypeAnnotation
  : '::' Type { Parser.Abs.TYPEANNOTATION $2 }
  | {- empty -} { Parser.Abs.TYPEANNOTATION_EMPTY }

Exp :: { Parser.Abs.Exp }
Exp : Exp1 { $1 }

Exp2 :: { Parser.Abs.Exp }
Exp2 : Exp3 { $1 }

Exp5 :: { Parser.Abs.Exp }
Exp5 : Exp6 { $1 }

Exp6 :: { Parser.Abs.Exp }
Exp6 : Exp7 { $1 }

Exp7 :: { Parser.Abs.Exp }
Exp7 : Exp8 { $1 }

Exp10 :: { Parser.Abs.Exp }
Exp10 : Exp11 { $1 }

Exp14 :: { Parser.Abs.Exp }
Exp14 : Exp15 { $1 }

ListExp :: { [Parser.Abs.Exp] }
ListExp
  : {- empty -} { [] }
  | Exp { (:[]) $1 }
  | Exp ',' ListExp { (:) $1 $3 }

ConstantType :: { Parser.Abs.ConstantType }
ConstantType
  : PInteger { Parser.Abs.INTEGER $1 }
  | String { Parser.Abs.STRING $1 }
  | Char { Parser.Abs.CHAR $1 }
  | Double { Parser.Abs.DOUBLE $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

