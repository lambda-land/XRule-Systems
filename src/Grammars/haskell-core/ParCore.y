-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParCore
  ( happyError
  , myLexer
  , pModule
  , pTdef
  , pListTdef
  , pMaybeTy
  , pCdef
  , pListTyt
  , pTyt
  , pListCdef
  , pVdefg
  , pListVdefg
  , pVdef
  , pListVdef
  , pExp2
  , pExp1
  , pExp
  , pBind
  , pListBind
  , pAlt
  , pListAlt
  , pVbind
  , pListVbind
  , pTbind
  , pListTbind
  , pATbind
  , pListATbind
  , pTy2
  , pTy1
  , pTy
  , pKind1
  , pKind
  , pLit
  , pQualIdent
  ) where

import Prelude

import qualified AbsCore
import LexCore

}

%name pModule_internal Module
%name pTdef_internal Tdef
%name pListTdef_internal ListTdef
%name pMaybeTy_internal MaybeTy
%name pCdef_internal Cdef
%name pListTyt_internal ListTyt
%name pTyt_internal Tyt
%name pListCdef_internal ListCdef
%name pVdefg_internal Vdefg
%name pListVdefg_internal ListVdefg
%name pVdef_internal Vdef
%name pListVdef_internal ListVdef
%name pExp2_internal Exp2
%name pExp1_internal Exp1
%name pExp_internal Exp
%name pBind_internal Bind
%name pListBind_internal ListBind
%name pAlt_internal Alt
%name pListAlt_internal ListAlt
%name pVbind_internal Vbind
%name pListVbind_internal ListVbind
%name pTbind_internal Tbind
%name pListTbind_internal ListTbind
%name pATbind_internal ATbind
%name pListATbind_internal ListATbind
%name pTy2_internal Ty2
%name pTy1_internal Ty1
%name pTy_internal Ty
%name pKind1_internal Kind1
%name pKind_internal Kind
%name pLit_internal Lit
%name pQualIdent_internal QualIdent
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '#'         { PT _ (TS _ 1)  }
  '%_'        { PT _ (TS _ 2)  }
  '%case'     { PT _ (TS _ 3)  }
  '%coerce'   { PT _ (TS _ 4)  }
  '%data'     { PT _ (TS _ 5)  }
  '%external' { PT _ (TS _ 6)  }
  '%forall'   { PT _ (TS _ 7)  }
  '%in'       { PT _ (TS _ 8)  }
  '%let'      { PT _ (TS _ 9)  }
  '%module'   { PT _ (TS _ 10) }
  '%newtype'  { PT _ (TS _ 11) }
  '%note'     { PT _ (TS _ 12) }
  '%of'       { PT _ (TS _ 13) }
  '%rec'      { PT _ (TS _ 14) }
  '('         { PT _ (TS _ 15) }
  ')'         { PT _ (TS _ 16) }
  '*'         { PT _ (TS _ 17) }
  '->'        { PT _ (TS _ 18) }
  '.'         { PT _ (TS _ 19) }
  '::'        { PT _ (TS _ 20) }
  ';'         { PT _ (TS _ 21) }
  '='         { PT _ (TS _ 22) }
  '?'         { PT _ (TS _ 23) }
  '@'         { PT _ (TS _ 24) }
  '\\'        { PT _ (TS _ 25) }
  '{'         { PT _ (TS _ 26) }
  '}'         { PT _ (TS _ 27) }
  L_Ident     { PT _ (TV _)    }
  L_charac    { PT _ (TC _)    }
  L_doubl     { PT _ (TD _)    }
  L_integ     { PT _ (TI _)    }
  L_quoted    { PT _ (TL _)    }

%%

Ident :: { (AbsCore.BNFC'Position, AbsCore.Ident) }
Ident  : L_Ident { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Ident (tokenText $1)) }

Char    :: { (AbsCore.BNFC'Position, Char) }
Char     : L_charac { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Char) }

Double  :: { (AbsCore.BNFC'Position, Double) }
Double   : L_doubl  { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Double) }

Integer :: { (AbsCore.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Integer) }

String  :: { (AbsCore.BNFC'Position, String) }
String   : L_quoted { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), ((\(PT _ (TL s)) -> s) $1)) }

Module :: { (AbsCore.BNFC'Position, AbsCore.Module) }
Module
  : '%module' Ident ListTdef ListVdefg { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Module (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3) (snd $4)) }

Tdef :: { (AbsCore.BNFC'Position, AbsCore.Tdef) }
Tdef
  : '%data' QualIdent ListTbind '=' '{' ListCdef '}' { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Data (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3) (snd $6)) }
  | '%newtype' QualIdent ListTbind MaybeTy { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Newtype (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3) (snd $4)) }

ListTdef :: { (AbsCore.BNFC'Position, [AbsCore.Tdef]) }
ListTdef
  : {- empty -} { (AbsCore.BNFC'NoPosition, []) }
  | Tdef ';' ListTdef { (fst $1, (:) (snd $1) (snd $3)) }

MaybeTy :: { (AbsCore.BNFC'Position, AbsCore.MaybeTy) }
MaybeTy
  : '=' Ty { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.JustTy (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | {- empty -} { (AbsCore.BNFC'NoPosition, AbsCore.NoTy AbsCore.BNFC'NoPosition) }

Cdef :: { (AbsCore.BNFC'Position, AbsCore.Cdef) }
Cdef
  : QualIdent ListATbind ListTyt { (fst $1, AbsCore.Constr (fst $1) (snd $1) (snd $2) (snd $3)) }

ListTyt :: { (AbsCore.BNFC'Position, [AbsCore.Tyt]) }
ListTyt
  : {- empty -} { (AbsCore.BNFC'NoPosition, []) }
  | Tyt ListTyt { (fst $1, (:) (snd $1) (snd $2)) }

Tyt :: { (AbsCore.BNFC'Position, AbsCore.Tyt) }
Tyt : Ty2 { (fst $1, AbsCore.TT (fst $1) (snd $1)) }

ListCdef :: { (AbsCore.BNFC'Position, [AbsCore.Cdef]) }
ListCdef
  : Cdef { (fst $1, (:[]) (snd $1)) }
  | Cdef ';' ListCdef { (fst $1, (:) (snd $1) (snd $3)) }

Vdefg :: { (AbsCore.BNFC'Position, AbsCore.Vdefg) }
Vdefg
  : '%rec' '{' ListVdef '}' { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Rec (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $3)) }
  | Vdef { (fst $1, AbsCore.Nonrec (fst $1) (snd $1)) }

ListVdefg :: { (AbsCore.BNFC'Position, [AbsCore.Vdefg]) }
ListVdefg
  : {- empty -} { (AbsCore.BNFC'NoPosition, []) }
  | Vdefg ';' ListVdefg { (fst $1, (:) (snd $1) (snd $3)) }

Vdef :: { (AbsCore.BNFC'Position, AbsCore.Vdef) }
Vdef
  : QualIdent '::' Ty '=' Exp { (fst $1, AbsCore.VdefQ (fst $1) (snd $1) (snd $3) (snd $5)) }
  | Ident '::' Ty '=' Exp { (fst $1, AbsCore.VdefU (fst $1) (snd $1) (snd $3) (snd $5)) }

ListVdef :: { (AbsCore.BNFC'Position, [AbsCore.Vdef]) }
ListVdef
  : Vdef { (fst $1, (:[]) (snd $1)) }
  | Vdef ';' ListVdef { (fst $1, (:) (snd $1) (snd $3)) }

Exp2 :: { (AbsCore.BNFC'Position, AbsCore.Exp) }
Exp2
  : Ident { (fst $1, AbsCore.Var (fst $1) (snd $1)) }
  | QualIdent { (fst $1, AbsCore.Dcon (fst $1) (snd $1)) }
  | Lit { (fst $1, AbsCore.Litc (fst $1) (snd $1)) }
  | '(' Exp ')' { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), (snd $2)) }

Exp1 :: { (AbsCore.BNFC'Position, AbsCore.Exp) }
Exp1
  : Exp1 Exp2 { (fst $1, AbsCore.App (fst $1) (snd $1) (snd $2)) }
  | Exp1 '@' Ty2 { (fst $1, AbsCore.Appt (fst $1) (snd $1) (snd $3)) }
  | Exp2 { (fst $1, (snd $1)) }

Exp :: { (AbsCore.BNFC'Position, AbsCore.Exp) }
Exp
  : '\\' ListBind '->' Exp { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Lams (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | '%let' Vdefg '%in' Exp { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Let (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | '%case' Exp2 '%of' Vbind '{' ListAlt '}' { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Case (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }
  | '%coerce' Ty2 Exp { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Coerce (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3)) }
  | '%note' String Exp { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Note (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3)) }
  | '%external' String Ty { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.External (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $3)) }
  | Exp1 { (fst $1, (snd $1)) }

Bind :: { (AbsCore.BNFC'Position, AbsCore.Bind) }
Bind
  : Vbind { (fst $1, AbsCore.Vb (fst $1) (snd $1)) }
  | '@' Tbind { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Tb (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ListBind :: { (AbsCore.BNFC'Position, [AbsCore.Bind]) }
ListBind
  : Bind { (fst $1, (:[]) (snd $1)) }
  | Bind ListBind { (fst $1, (:) (snd $1) (snd $2)) }

Alt :: { (AbsCore.BNFC'Position, AbsCore.Alt) }
Alt
  : QualIdent ListATbind ListVbind '->' Exp { (fst $1, AbsCore.Acon (fst $1) (snd $1) (snd $2) (snd $3) (snd $5)) }
  | Lit '->' Exp { (fst $1, AbsCore.Alit (fst $1) (snd $1) (snd $3)) }
  | '%_' '->' Exp { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Adefault (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $3)) }

ListAlt :: { (AbsCore.BNFC'Position, [AbsCore.Alt]) }
ListAlt
  : Alt { (fst $1, (:[]) (snd $1)) }
  | Alt ';' ListAlt { (fst $1, (:) (snd $1) (snd $3)) }

Vbind :: { (AbsCore.BNFC'Position, AbsCore.Vbind) }
Vbind
  : '(' Ident '::' Ty ')' { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Vbind (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }

ListVbind :: { (AbsCore.BNFC'Position, [AbsCore.Vbind]) }
ListVbind
  : {- empty -} { (AbsCore.BNFC'NoPosition, []) }
  | Vbind ListVbind { (fst $1, (:) (snd $1) (snd $2)) }

Tbind :: { (AbsCore.BNFC'Position, AbsCore.Tbind) }
Tbind
  : '(' Ident '::' Kind1 ')' { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.TbindPair (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | Ident { (fst $1, AbsCore.TbindLift (fst $1) (snd $1)) }

ListTbind :: { (AbsCore.BNFC'Position, [AbsCore.Tbind]) }
ListTbind
  : {- empty -} { (AbsCore.BNFC'NoPosition, []) }
  | Tbind ListTbind { (fst $1, (:) (snd $1) (snd $2)) }

ATbind :: { (AbsCore.BNFC'Position, AbsCore.ATbind) }
ATbind
  : '@' Tbind { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.ATbind (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2)) }

ListATbind :: { (AbsCore.BNFC'Position, [AbsCore.ATbind]) }
ListATbind
  : {- empty -} { (AbsCore.BNFC'NoPosition, []) }
  | ATbind ListATbind { (fst $1, (:) (snd $1) (snd $2)) }

Ty2 :: { (AbsCore.BNFC'Position, AbsCore.Ty) }
Ty2
  : Ident { (fst $1, AbsCore.Tvar (fst $1) (snd $1)) }
  | QualIdent { (fst $1, AbsCore.Tcon (fst $1) (snd $1)) }
  | '(' Ty ')' { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), (snd $2)) }

Ty1 :: { (AbsCore.BNFC'Position, AbsCore.Ty) }
Ty1
  : Ty1 Ty2 { (fst $1, AbsCore.Tapp (fst $1) (snd $1) (snd $2)) }
  | Ty2 { (fst $1, (snd $1)) }

Ty :: { (AbsCore.BNFC'Position, AbsCore.Ty) }
Ty
  : Ty1 '->' Ty { (fst $1, AbsCore.TArrow (fst $1) (snd $1) (snd $3)) }
  | '%forall' ListTbind '.' Ty { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Tforalls (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | Ty1 { (fst $1, (snd $1)) }

Kind1 :: { (AbsCore.BNFC'Position, AbsCore.Kind) }
Kind1
  : '*' { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Klifted (uncurry AbsCore.BNFC'Position (tokenLineCol $1))) }
  | '#' { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Kunlifted (uncurry AbsCore.BNFC'Position (tokenLineCol $1))) }
  | '?' { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Kopen (uncurry AbsCore.BNFC'Position (tokenLineCol $1))) }
  | '(' Kind ')' { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), (snd $2)) }

Kind :: { (AbsCore.BNFC'Position, AbsCore.Kind) }
Kind
  : Kind1 '->' Kind { (fst $1, AbsCore.Karrow (fst $1) (snd $1) (snd $3)) }
  | Kind1 { (fst $1, (snd $1)) }

Lit :: { (AbsCore.BNFC'Position, AbsCore.Lit) }
Lit
  : '(' Integer '::' Ty2 ')' { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Lint (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | '(' Double '::' Ty2 ')' { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Lrational (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | '(' Char '::' Ty2 ')' { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Lchar (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | '(' String '::' Ty2 ')' { (uncurry AbsCore.BNFC'Position (tokenLineCol $1), AbsCore.Lstring (uncurry AbsCore.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }

QualIdent :: { (AbsCore.BNFC'Position, AbsCore.QualIdent) }
QualIdent
  : Ident '.' Ident { (fst $1, AbsCore.Qual (fst $1) (snd $1) (snd $3)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pModule :: [Token] -> Err AbsCore.Module
pModule = fmap snd . pModule_internal

pTdef :: [Token] -> Err AbsCore.Tdef
pTdef = fmap snd . pTdef_internal

pListTdef :: [Token] -> Err [AbsCore.Tdef]
pListTdef = fmap snd . pListTdef_internal

pMaybeTy :: [Token] -> Err AbsCore.MaybeTy
pMaybeTy = fmap snd . pMaybeTy_internal

pCdef :: [Token] -> Err AbsCore.Cdef
pCdef = fmap snd . pCdef_internal

pListTyt :: [Token] -> Err [AbsCore.Tyt]
pListTyt = fmap snd . pListTyt_internal

pTyt :: [Token] -> Err AbsCore.Tyt
pTyt = fmap snd . pTyt_internal

pListCdef :: [Token] -> Err [AbsCore.Cdef]
pListCdef = fmap snd . pListCdef_internal

pVdefg :: [Token] -> Err AbsCore.Vdefg
pVdefg = fmap snd . pVdefg_internal

pListVdefg :: [Token] -> Err [AbsCore.Vdefg]
pListVdefg = fmap snd . pListVdefg_internal

pVdef :: [Token] -> Err AbsCore.Vdef
pVdef = fmap snd . pVdef_internal

pListVdef :: [Token] -> Err [AbsCore.Vdef]
pListVdef = fmap snd . pListVdef_internal

pExp2 :: [Token] -> Err AbsCore.Exp
pExp2 = fmap snd . pExp2_internal

pExp1 :: [Token] -> Err AbsCore.Exp
pExp1 = fmap snd . pExp1_internal

pExp :: [Token] -> Err AbsCore.Exp
pExp = fmap snd . pExp_internal

pBind :: [Token] -> Err AbsCore.Bind
pBind = fmap snd . pBind_internal

pListBind :: [Token] -> Err [AbsCore.Bind]
pListBind = fmap snd . pListBind_internal

pAlt :: [Token] -> Err AbsCore.Alt
pAlt = fmap snd . pAlt_internal

pListAlt :: [Token] -> Err [AbsCore.Alt]
pListAlt = fmap snd . pListAlt_internal

pVbind :: [Token] -> Err AbsCore.Vbind
pVbind = fmap snd . pVbind_internal

pListVbind :: [Token] -> Err [AbsCore.Vbind]
pListVbind = fmap snd . pListVbind_internal

pTbind :: [Token] -> Err AbsCore.Tbind
pTbind = fmap snd . pTbind_internal

pListTbind :: [Token] -> Err [AbsCore.Tbind]
pListTbind = fmap snd . pListTbind_internal

pATbind :: [Token] -> Err AbsCore.ATbind
pATbind = fmap snd . pATbind_internal

pListATbind :: [Token] -> Err [AbsCore.ATbind]
pListATbind = fmap snd . pListATbind_internal

pTy2 :: [Token] -> Err AbsCore.Ty
pTy2 = fmap snd . pTy2_internal

pTy1 :: [Token] -> Err AbsCore.Ty
pTy1 = fmap snd . pTy1_internal

pTy :: [Token] -> Err AbsCore.Ty
pTy = fmap snd . pTy_internal

pKind1 :: [Token] -> Err AbsCore.Kind
pKind1 = fmap snd . pKind1_internal

pKind :: [Token] -> Err AbsCore.Kind
pKind = fmap snd . pKind_internal

pLit :: [Token] -> Err AbsCore.Lit
pLit = fmap snd . pLit_internal

pQualIdent :: [Token] -> Err AbsCore.QualIdent
pQualIdent = fmap snd . pQualIdent_internal
}

