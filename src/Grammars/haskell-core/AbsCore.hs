-- File generated by the BNF Converter (bnfc 2.9.4).

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language Core.

module AbsCore where

import Prelude (Char, Double, Integer, String)
import qualified Prelude as C
  ( Eq, Ord, Show, Read
  , Functor, Foldable, Traversable
  , Int, Maybe(..)
  )
import qualified Data.String

import qualified Data.Data    as C (Data, Typeable)
import qualified GHC.Generics as C (Generic)

type Module = Module' BNFC'Position
data Module' a = Module a Ident [Tdef' a] [Vdefg' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Tdef = Tdef' BNFC'Position
data Tdef' a
    = Data a (QualIdent' a) [Tbind' a] [Cdef' a]
    | Newtype a (QualIdent' a) [Tbind' a] (MaybeTy' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type MaybeTy = MaybeTy' BNFC'Position
data MaybeTy' a = JustTy a (Ty' a) | NoTy a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Cdef = Cdef' BNFC'Position
data Cdef' a = Constr a (QualIdent' a) [ATbind' a] [Tyt' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Tyt = Tyt' BNFC'Position
data Tyt' a = TT a (Ty' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Vdefg = Vdefg' BNFC'Position
data Vdefg' a = Rec a [Vdef' a] | Nonrec a (Vdef' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Vdef = Vdef' BNFC'Position
data Vdef' a
    = VdefQ a (QualIdent' a) (Ty' a) (Exp' a)
    | VdefU a Ident (Ty' a) (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Exp = Exp' BNFC'Position
data Exp' a
    = Var a Ident
    | Dcon a (QualIdent' a)
    | Litc a (Lit' a)
    | App a (Exp' a) (Exp' a)
    | Appt a (Exp' a) (Ty' a)
    | Lams a [Bind' a] (Exp' a)
    | Let a (Vdefg' a) (Exp' a)
    | Case a (Exp' a) (Vbind' a) [Alt' a]
    | Coerce a (Ty' a) (Exp' a)
    | Note a String (Exp' a)
    | External a String (Ty' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Bind = Bind' BNFC'Position
data Bind' a = Vb a (Vbind' a) | Tb a (Tbind' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Alt = Alt' BNFC'Position
data Alt' a
    = Acon a (QualIdent' a) [ATbind' a] [Vbind' a] (Exp' a)
    | Alit a (Lit' a) (Exp' a)
    | Adefault a (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Vbind = Vbind' BNFC'Position
data Vbind' a = Vbind a Ident (Ty' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Tbind = Tbind' BNFC'Position
data Tbind' a = TbindPair a Ident (Kind' a) | TbindLift a Ident
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type ATbind = ATbind' BNFC'Position
data ATbind' a = ATbind a (Tbind' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Ty = Ty' BNFC'Position
data Ty' a
    = Tvar a Ident
    | Tcon a (QualIdent' a)
    | Tapp a (Ty' a) (Ty' a)
    | TArrow a (Ty' a) (Ty' a)
    | Tforalls a [Tbind' a] (Ty' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Kind = Kind' BNFC'Position
data Kind' a
    = Klifted a | Kunlifted a | Kopen a | Karrow a (Kind' a) (Kind' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Lit = Lit' BNFC'Position
data Lit' a
    = Lint a Integer (Ty' a)
    | Lrational a Double (Ty' a)
    | Lchar a Char (Ty' a)
    | Lstring a String (Ty' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type QualIdent = QualIdent' BNFC'Position
data QualIdent' a = Qual a Ident Ident
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

newtype Ident = Ident String
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

-- | Start position (line, column) of something.

type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.

class HasPosition a where
  hasPosition :: a -> BNFC'Position

instance HasPosition Module where
  hasPosition = \case
    Module p _ _ _ -> p

instance HasPosition Tdef where
  hasPosition = \case
    Data p _ _ _ -> p
    Newtype p _ _ _ -> p

instance HasPosition MaybeTy where
  hasPosition = \case
    JustTy p _ -> p
    NoTy p -> p

instance HasPosition Cdef where
  hasPosition = \case
    Constr p _ _ _ -> p

instance HasPosition Tyt where
  hasPosition = \case
    TT p _ -> p

instance HasPosition Vdefg where
  hasPosition = \case
    Rec p _ -> p
    Nonrec p _ -> p

instance HasPosition Vdef where
  hasPosition = \case
    VdefQ p _ _ _ -> p
    VdefU p _ _ _ -> p

instance HasPosition Exp where
  hasPosition = \case
    Var p _ -> p
    Dcon p _ -> p
    Litc p _ -> p
    App p _ _ -> p
    Appt p _ _ -> p
    Lams p _ _ -> p
    Let p _ _ -> p
    Case p _ _ _ -> p
    Coerce p _ _ -> p
    Note p _ _ -> p
    External p _ _ -> p

instance HasPosition Bind where
  hasPosition = \case
    Vb p _ -> p
    Tb p _ -> p

instance HasPosition Alt where
  hasPosition = \case
    Acon p _ _ _ _ -> p
    Alit p _ _ -> p
    Adefault p _ -> p

instance HasPosition Vbind where
  hasPosition = \case
    Vbind p _ _ -> p

instance HasPosition Tbind where
  hasPosition = \case
    TbindPair p _ _ -> p
    TbindLift p _ -> p

instance HasPosition ATbind where
  hasPosition = \case
    ATbind p _ -> p

instance HasPosition Ty where
  hasPosition = \case
    Tvar p _ -> p
    Tcon p _ -> p
    Tapp p _ _ -> p
    TArrow p _ _ -> p
    Tforalls p _ _ -> p

instance HasPosition Kind where
  hasPosition = \case
    Klifted p -> p
    Kunlifted p -> p
    Kopen p -> p
    Karrow p _ _ -> p

instance HasPosition Lit where
  hasPosition = \case
    Lint p _ _ -> p
    Lrational p _ _ -> p
    Lchar p _ _ -> p
    Lstring p _ _ -> p

instance HasPosition QualIdent where
  hasPosition = \case
    Qual p _ _ -> p

