-- File generated by the BNF Converter (bnfc 2.9.4).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module MFL.Skel where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified MFL.Abs

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transTokUnit :: MFL.Abs.TokUnit -> Result
transTokUnit x = case x of
  MFL.Abs.TokUnit string -> failure x

transUIdent :: MFL.Abs.UIdent -> Result
transUIdent x = case x of
  MFL.Abs.UIdent string -> failure x

transPIdent :: MFL.Abs.PIdent -> Result
transPIdent x = case x of
  MFL.Abs.PIdent string -> failure x

transPInteger :: MFL.Abs.PInteger -> Result
transPInteger x = case x of
  MFL.Abs.PInteger string -> failure x

transSCPL :: MFL.Abs.SCPL -> Result
transSCPL x = case x of
  MFL.Abs.SCPLPROG defns -> failure x

transDefn :: MFL.Abs.Defn -> Result
transDefn x = case x of
  MFL.Abs.DEFN pident stmt -> failure x

transStmt :: MFL.Abs.Stmt -> Result
transStmt x = case x of
  MFL.Abs.CASESTMT exp caseterms -> failure x
  MFL.Abs.IFSTMT exp stmt1 stmt2 -> failure x
  MFL.Abs.BARESTMT exp -> failure x
  MFL.Abs.ELet let_ letinstmt stmt -> failure x

transLet :: MFL.Abs.Let -> Result
transLet x = case x of
  MFL.Abs.LET -> failure x
  MFL.Abs.LRec -> failure x

transCaseTerm :: MFL.Abs.CaseTerm -> Result
transCaseTerm x = case x of
  MFL.Abs.CASE_STMT casepattern stmt -> failure x

transLetInStmt :: MFL.Abs.LetInStmt -> Result
transLetInStmt x = case x of
  MFL.Abs.LET_IN_STMT pident exp -> failure x

transType :: MFL.Abs.Type -> Result
transType x = case x of
  MFL.Abs.TYPEARROW typen type_ -> failure x
  MFL.Abs.TYPENext typen -> failure x

transTypeN :: MFL.Abs.TypeN -> Result
transTypeN x = case x of
  MFL.Abs.TYPEUNIT tokunit -> failure x
  MFL.Abs.TYPECONST_VAR uident -> failure x
  MFL.Abs.TYPELIST type_ -> failure x
  MFL.Abs.TYPEPROD types -> failure x
  MFL.Abs.TYPEBRACKET type_ -> failure x
  MFL.Abs.CONST_TYPE constanttype -> failure x

transCasePattern :: MFL.Abs.CasePattern -> Result
transCasePattern x = case x of
  MFL.Abs.TRUE_PATTERN -> failure x
  MFL.Abs.FALSE_PATTERN -> failure x

transExp :: MFL.Abs.Exp -> Result
transExp x = case x of
  MFL.Abs.EInt pinteger -> failure x
  MFL.Abs.ETrue -> failure x
  MFL.Abs.EFalse -> failure x
  MFL.Abs.EVar pident -> failure x
  MFL.Abs.EString string -> failure x
  MFL.Abs.EList exps -> failure x
  MFL.Abs.ECall pident exps -> failure x
  MFL.Abs.ENeg exp -> failure x
  MFL.Abs.CONSTERM exp1 exp2 -> failure x
  MFL.Abs.EAPPEND exp1 exp2 -> failure x
  MFL.Abs.EMul exp1 exp2 -> failure x
  MFL.Abs.EDiv exp1 exp2 -> failure x
  MFL.Abs.EAdd exp1 exp2 -> failure x
  MFL.Abs.ESub exp1 exp2 -> failure x
  MFL.Abs.ELt exp1 exp2 -> failure x
  MFL.Abs.EGt exp1 exp2 -> failure x
  MFL.Abs.ELEq exp1 exp2 -> failure x
  MFL.Abs.EGEq exp1 exp2 -> failure x
  MFL.Abs.EEq exp1 exp2 -> failure x
  MFL.Abs.ENEq exp1 exp2 -> failure x
  MFL.Abs.EAnd exp1 exp2 -> failure x
  MFL.Abs.EOr exp1 exp2 -> failure x
  MFL.Abs.ELambda pidents stmt -> failure x

transTypeAnnotation :: MFL.Abs.TypeAnnotation -> Result
transTypeAnnotation x = case x of
  MFL.Abs.TYPEANNOTATION type_ -> failure x
  MFL.Abs.TYPEANNOTATION_EMPTY -> failure x

transConstantType :: MFL.Abs.ConstantType -> Result
transConstantType x = case x of
  MFL.Abs.INTEGER pinteger -> failure x
  MFL.Abs.STRING string -> failure x
  MFL.Abs.CHAR char -> failure x
  MFL.Abs.DOUBLE double -> failure x
