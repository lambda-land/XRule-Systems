-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module MFL.Par
  ( happyError
  , myLexer
  , pSCPL
  , pListDefn
  , pDefn
  , pStmt2
  , pLet
  , pStmt1
  , pCaseTerm
  , pLetInStmt
  , pType
  , pTypeN
  , pListTypeN
  , pListType
  , pListUIdent
  , pCasePattern
  , pListCaseTerm
  , pExp15
  , pExp13
  , pExp12
  , pExp11
  , pExp9
  , pExp8
  , pExp4
  , pExp3
  , pExp1
  , pListPIdent
  , pTypeAnnotation
  , pExp
  , pExp2
  , pExp5
  , pExp6
  , pExp7
  , pExp10
  , pExp14
  , pListExp
  , pConstantType
  ) where

import Prelude

import qualified MFL.Abs
import MFL.Lex

}

%name pSCPL_internal SCPL
%name pListDefn_internal ListDefn
%name pDefn_internal Defn
%name pStmt2_internal Stmt2
%name pLet_internal Let
%name pStmt1_internal Stmt1
%name pCaseTerm_internal CaseTerm
%name pLetInStmt_internal LetInStmt
%name pType_internal Type
%name pTypeN_internal TypeN
%name pListTypeN_internal ListTypeN
%name pListType_internal ListType
%name pListUIdent_internal ListUIdent
%name pCasePattern_internal CasePattern
%name pListCaseTerm_internal ListCaseTerm
%name pExp15_internal Exp15
%name pExp13_internal Exp13
%name pExp12_internal Exp12
%name pExp11_internal Exp11
%name pExp9_internal Exp9
%name pExp8_internal Exp8
%name pExp4_internal Exp4
%name pExp3_internal Exp3
%name pExp1_internal Exp1
%name pListPIdent_internal ListPIdent
%name pTypeAnnotation_internal TypeAnnotation
%name pExp_internal Exp
%name pExp2_internal Exp2
%name pExp5_internal Exp5
%name pExp6_internal Exp6
%name pExp7_internal Exp7
%name pExp10_internal Exp10
%name pExp14_internal Exp14
%name pListExp_internal ListExp
%name pConstantType_internal ConstantType
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='       { PT _ (TS _ 1)       }
  '&&'       { PT _ (TS _ 2)       }
  '('        { PT _ (TS _ 3)       }
  ')'        { PT _ (TS _ 4)       }
  '*'        { PT _ (TS _ 5)       }
  '+'        { PT _ (TS _ 6)       }
  '++'       { PT _ (TS _ 7)       }
  ','        { PT _ (TS _ 8)       }
  '-'        { PT _ (TS _ 9)       }
  '->'       { PT _ (TS _ 10)      }
  '/'        { PT _ (TS _ 11)      }
  ':'        { PT _ (TS _ 12)      }
  '::'       { PT _ (TS _ 13)      }
  ';'        { PT _ (TS _ 14)      }
  '<'        { PT _ (TS _ 15)      }
  '<='       { PT _ (TS _ 16)      }
  '='        { PT _ (TS _ 17)      }
  '=='       { PT _ (TS _ 18)      }
  '>'        { PT _ (TS _ 19)      }
  '>='       { PT _ (TS _ 20)      }
  'False'    { PT _ (TS _ 21)      }
  'True'     { PT _ (TS _ 22)      }
  '['        { PT _ (TS _ 23)      }
  '\\'       { PT _ (TS _ 24)      }
  ']'        { PT _ (TS _ 25)      }
  'case'     { PT _ (TS _ 26)      }
  'else'     { PT _ (TS _ 27)      }
  'if'       { PT _ (TS _ 28)      }
  'in'       { PT _ (TS _ 29)      }
  'let'      { PT _ (TS _ 30)      }
  'letrec'   { PT _ (TS _ 31)      }
  'of'       { PT _ (TS _ 32)      }
  'then'     { PT _ (TS _ 33)      }
  '{'        { PT _ (TS _ 34)      }
  '||'       { PT _ (TS _ 35)      }
  '}'        { PT _ (TS _ 36)      }
  L_charac   { PT _ (TC _)         }
  L_doubl    { PT _ (TD _)         }
  L_quoted   { PT _ (TL _)         }
  L_TokUnit  { PT _ (T_TokUnit _)  }
  L_UIdent   { PT _ (T_UIdent _)   }
  L_PIdent   { PT _ (T_PIdent _)   }
  L_PInteger { PT _ (T_PInteger _) }

%%

Char    :: { (MFL.Abs.BNFC'Position, Char) }
Char     : L_charac { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Char) }

Double  :: { (MFL.Abs.BNFC'Position, Double) }
Double   : L_doubl  { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Double) }

String  :: { (MFL.Abs.BNFC'Position, String) }
String   : L_quoted { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), ((\(PT _ (TL s)) -> s) $1)) }

TokUnit :: { (MFL.Abs.BNFC'Position, MFL.Abs.TokUnit) }
TokUnit  : L_TokUnit { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.TokUnit (mkPosToken $1)) }

UIdent :: { (MFL.Abs.BNFC'Position, MFL.Abs.UIdent) }
UIdent  : L_UIdent { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.UIdent (mkPosToken $1)) }

PIdent :: { (MFL.Abs.BNFC'Position, MFL.Abs.PIdent) }
PIdent  : L_PIdent { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.PIdent (mkPosToken $1)) }

PInteger :: { (MFL.Abs.BNFC'Position, MFL.Abs.PInteger) }
PInteger  : L_PInteger { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.PInteger (mkPosToken $1)) }

SCPL :: { (MFL.Abs.BNFC'Position, MFL.Abs.SCPL) }
SCPL : ListDefn { (fst $1, MFL.Abs.SCPLPROG (fst $1) (snd $1)) }

ListDefn :: { (MFL.Abs.BNFC'Position, [MFL.Abs.Defn]) }
ListDefn
  : Defn { (fst $1, (:[]) (snd $1)) }
  | Defn ListDefn { (fst $1, (:) (snd $1) (snd $2)) }

Defn :: { (MFL.Abs.BNFC'Position, MFL.Abs.Defn) }
Defn
  : PIdent '=' Stmt1 { (fst $1, MFL.Abs.DEFN (fst $1) (snd $1) (snd $3)) }

Stmt2 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Stmt) }
Stmt2
  : 'case' Exp 'of' '{' ListCaseTerm '}' { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.CASESTMT (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $5)) }
  | 'if' Exp 'then' Stmt2 'else' Stmt2 { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.IFSTMT (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4) (snd $6)) }
  | Exp { (fst $1, MFL.Abs.BARESTMT (fst $1) (snd $1)) }

Let :: { (MFL.Abs.BNFC'Position, MFL.Abs.Let) }
Let
  : 'let' { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.LET (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1))) }
  | 'letrec' { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.LRec (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1))) }

Stmt1 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Stmt) }
Stmt1
  : Let LetInStmt 'in' Stmt1 { (fst $1, MFL.Abs.ELet (fst $1) (snd $1) (snd $2) (snd $4)) }
  | Stmt2 { (fst $1, (snd $1)) }

CaseTerm :: { (MFL.Abs.BNFC'Position, MFL.Abs.CaseTerm) }
CaseTerm
  : CasePattern '->' Stmt1 { (fst $1, MFL.Abs.CASE_STMT (fst $1) (snd $1) (snd $3)) }

LetInStmt :: { (MFL.Abs.BNFC'Position, MFL.Abs.LetInStmt) }
LetInStmt
  : PIdent '=' Exp { (fst $1, MFL.Abs.LET_IN_STMT (fst $1) (snd $1) (snd $3)) }

Type :: { (MFL.Abs.BNFC'Position, MFL.Abs.Type) }
Type
  : TypeN '->' Type { (fst $1, MFL.Abs.TYPEARROW (fst $1) (snd $1) (snd $3)) }
  | TypeN { (fst $1, MFL.Abs.TYPENext (fst $1) (snd $1)) }

TypeN :: { (MFL.Abs.BNFC'Position, MFL.Abs.TypeN) }
TypeN
  : TokUnit { (fst $1, MFL.Abs.TYPEUNIT (fst $1) (snd $1)) }
  | UIdent { (fst $1, MFL.Abs.TYPECONST_VAR (fst $1) (snd $1)) }
  | '[' Type ']' { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.TYPELIST (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '<' ListType '>' { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.TYPEPROD (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '(' Type ')' { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.TYPEBRACKET (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | ConstantType { (fst $1, MFL.Abs.CONST_TYPE (fst $1) (snd $1)) }

ListTypeN :: { (MFL.Abs.BNFC'Position, [MFL.Abs.TypeN]) }
ListTypeN
  : {- empty -} { (MFL.Abs.BNFC'NoPosition, []) }
  | TypeN { (fst $1, (:[]) (snd $1)) }
  | TypeN ',' ListTypeN { (fst $1, (:) (snd $1) (snd $3)) }

ListType :: { (MFL.Abs.BNFC'Position, [MFL.Abs.Type]) }
ListType
  : Type { (fst $1, (:[]) (snd $1)) }
  | Type ',' ListType { (fst $1, (:) (snd $1) (snd $3)) }

ListUIdent :: { (MFL.Abs.BNFC'Position, [MFL.Abs.UIdent]) }
ListUIdent
  : {- empty -} { (MFL.Abs.BNFC'NoPosition, []) }
  | UIdent { (fst $1, (:[]) (snd $1)) }
  | UIdent ',' ListUIdent { (fst $1, (:) (snd $1) (snd $3)) }

CasePattern :: { (MFL.Abs.BNFC'Position, MFL.Abs.CasePattern) }
CasePattern
  : 'True' { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.TRUE_PATTERN (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1))) }
  | 'False' { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.FALSE_PATTERN (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1))) }

ListCaseTerm :: { (MFL.Abs.BNFC'Position, [MFL.Abs.CaseTerm]) }
ListCaseTerm
  : CaseTerm { (fst $1, (:[]) (snd $1)) }
  | CaseTerm ';' ListCaseTerm { (fst $1, (:) (snd $1) (snd $3)) }

Exp15 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Exp) }
Exp15
  : PInteger { (fst $1, MFL.Abs.EInt (fst $1) (snd $1)) }
  | 'True' { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.ETrue (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1))) }
  | 'False' { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.EFalse (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1))) }
  | PIdent { (fst $1, MFL.Abs.EVar (fst $1) (snd $1)) }
  | String { (fst $1, MFL.Abs.EString (fst $1) (snd $1)) }
  | '[' ListExp ']' { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.EList (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | PIdent '(' ListExp ')' { (fst $1, MFL.Abs.ECall (fst $1) (snd $1) (snd $3)) }
  | '(' Exp ')' { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

Exp13 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Exp) }
Exp13
  : '-' Exp14 { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.ENeg (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | Exp13 ':' Exp14 { (fst $1, MFL.Abs.CONSTERM (fst $1) (snd $1) (snd $3)) }
  | Exp14 { (fst $1, (snd $1)) }

Exp12 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Exp) }
Exp12
  : Exp12 '++' Exp13 { (fst $1, MFL.Abs.EAPPEND (fst $1) (snd $1) (snd $3)) }
  | Exp12 '*' Exp13 { (fst $1, MFL.Abs.EMul (fst $1) (snd $1) (snd $3)) }
  | Exp12 '/' Exp13 { (fst $1, MFL.Abs.EDiv (fst $1) (snd $1) (snd $3)) }
  | Exp13 { (fst $1, (snd $1)) }

Exp11 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Exp) }
Exp11
  : Exp11 '+' Exp12 { (fst $1, MFL.Abs.EAdd (fst $1) (snd $1) (snd $3)) }
  | Exp11 '-' Exp12 { (fst $1, MFL.Abs.ESub (fst $1) (snd $1) (snd $3)) }
  | Exp12 { (fst $1, (snd $1)) }

Exp9 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Exp) }
Exp9
  : Exp9 '<' Exp10 { (fst $1, MFL.Abs.ELt (fst $1) (snd $1) (snd $3)) }
  | Exp9 '>' Exp10 { (fst $1, MFL.Abs.EGt (fst $1) (snd $1) (snd $3)) }
  | Exp9 '<=' Exp10 { (fst $1, MFL.Abs.ELEq (fst $1) (snd $1) (snd $3)) }
  | Exp9 '>=' Exp10 { (fst $1, MFL.Abs.EGEq (fst $1) (snd $1) (snd $3)) }
  | Exp10 { (fst $1, (snd $1)) }

Exp8 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Exp) }
Exp8
  : Exp8 '==' Exp9 { (fst $1, MFL.Abs.EEq (fst $1) (snd $1) (snd $3)) }
  | Exp8 '!=' Exp9 { (fst $1, MFL.Abs.ENEq (fst $1) (snd $1) (snd $3)) }
  | Exp9 { (fst $1, (snd $1)) }

Exp4 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Exp) }
Exp4
  : Exp4 '&&' Exp5 { (fst $1, MFL.Abs.EAnd (fst $1) (snd $1) (snd $3)) }
  | Exp5 { (fst $1, (snd $1)) }

Exp3 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Exp) }
Exp3
  : Exp3 '||' Exp4 { (fst $1, MFL.Abs.EOr (fst $1) (snd $1) (snd $3)) }
  | Exp4 { (fst $1, (snd $1)) }

Exp1 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Exp) }
Exp1
  : '\\' ListPIdent '->' Stmt1 { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.ELambda (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | Exp2 { (fst $1, (snd $1)) }

ListPIdent :: { (MFL.Abs.BNFC'Position, [MFL.Abs.PIdent]) }
ListPIdent
  : PIdent { (fst $1, (:[]) (snd $1)) }
  | PIdent ListPIdent { (fst $1, (:) (snd $1) (snd $2)) }

TypeAnnotation :: { (MFL.Abs.BNFC'Position, MFL.Abs.TypeAnnotation) }
TypeAnnotation
  : '::' Type { (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1), MFL.Abs.TYPEANNOTATION (uncurry MFL.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | {- empty -} { (MFL.Abs.BNFC'NoPosition, MFL.Abs.TYPEANNOTATION_EMPTY MFL.Abs.BNFC'NoPosition) }

Exp :: { (MFL.Abs.BNFC'Position, MFL.Abs.Exp) }
Exp : Exp1 { (fst $1, (snd $1)) }

Exp2 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Exp) }
Exp2 : Exp3 { (fst $1, (snd $1)) }

Exp5 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Exp) }
Exp5 : Exp6 { (fst $1, (snd $1)) }

Exp6 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Exp) }
Exp6 : Exp7 { (fst $1, (snd $1)) }

Exp7 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Exp) }
Exp7 : Exp8 { (fst $1, (snd $1)) }

Exp10 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Exp) }
Exp10 : Exp11 { (fst $1, (snd $1)) }

Exp14 :: { (MFL.Abs.BNFC'Position, MFL.Abs.Exp) }
Exp14 : Exp15 { (fst $1, (snd $1)) }

ListExp :: { (MFL.Abs.BNFC'Position, [MFL.Abs.Exp]) }
ListExp
  : {- empty -} { (MFL.Abs.BNFC'NoPosition, []) }
  | Exp { (fst $1, (:[]) (snd $1)) }
  | Exp ',' ListExp { (fst $1, (:) (snd $1) (snd $3)) }

ConstantType :: { (MFL.Abs.BNFC'Position, MFL.Abs.ConstantType) }
ConstantType
  : PInteger { (fst $1, MFL.Abs.INTEGER (fst $1) (snd $1)) }
  | String { (fst $1, MFL.Abs.STRING (fst $1) (snd $1)) }
  | Char { (fst $1, MFL.Abs.CHAR (fst $1) (snd $1)) }
  | Double { (fst $1, MFL.Abs.DOUBLE (fst $1) (snd $1)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pSCPL :: [Token] -> Err MFL.Abs.SCPL
pSCPL = fmap snd . pSCPL_internal

pListDefn :: [Token] -> Err [MFL.Abs.Defn]
pListDefn = fmap snd . pListDefn_internal

pDefn :: [Token] -> Err MFL.Abs.Defn
pDefn = fmap snd . pDefn_internal

pStmt2 :: [Token] -> Err MFL.Abs.Stmt
pStmt2 = fmap snd . pStmt2_internal

pLet :: [Token] -> Err MFL.Abs.Let
pLet = fmap snd . pLet_internal

pStmt1 :: [Token] -> Err MFL.Abs.Stmt
pStmt1 = fmap snd . pStmt1_internal

pCaseTerm :: [Token] -> Err MFL.Abs.CaseTerm
pCaseTerm = fmap snd . pCaseTerm_internal

pLetInStmt :: [Token] -> Err MFL.Abs.LetInStmt
pLetInStmt = fmap snd . pLetInStmt_internal

pType :: [Token] -> Err MFL.Abs.Type
pType = fmap snd . pType_internal

pTypeN :: [Token] -> Err MFL.Abs.TypeN
pTypeN = fmap snd . pTypeN_internal

pListTypeN :: [Token] -> Err [MFL.Abs.TypeN]
pListTypeN = fmap snd . pListTypeN_internal

pListType :: [Token] -> Err [MFL.Abs.Type]
pListType = fmap snd . pListType_internal

pListUIdent :: [Token] -> Err [MFL.Abs.UIdent]
pListUIdent = fmap snd . pListUIdent_internal

pCasePattern :: [Token] -> Err MFL.Abs.CasePattern
pCasePattern = fmap snd . pCasePattern_internal

pListCaseTerm :: [Token] -> Err [MFL.Abs.CaseTerm]
pListCaseTerm = fmap snd . pListCaseTerm_internal

pExp15 :: [Token] -> Err MFL.Abs.Exp
pExp15 = fmap snd . pExp15_internal

pExp13 :: [Token] -> Err MFL.Abs.Exp
pExp13 = fmap snd . pExp13_internal

pExp12 :: [Token] -> Err MFL.Abs.Exp
pExp12 = fmap snd . pExp12_internal

pExp11 :: [Token] -> Err MFL.Abs.Exp
pExp11 = fmap snd . pExp11_internal

pExp9 :: [Token] -> Err MFL.Abs.Exp
pExp9 = fmap snd . pExp9_internal

pExp8 :: [Token] -> Err MFL.Abs.Exp
pExp8 = fmap snd . pExp8_internal

pExp4 :: [Token] -> Err MFL.Abs.Exp
pExp4 = fmap snd . pExp4_internal

pExp3 :: [Token] -> Err MFL.Abs.Exp
pExp3 = fmap snd . pExp3_internal

pExp1 :: [Token] -> Err MFL.Abs.Exp
pExp1 = fmap snd . pExp1_internal

pListPIdent :: [Token] -> Err [MFL.Abs.PIdent]
pListPIdent = fmap snd . pListPIdent_internal

pTypeAnnotation :: [Token] -> Err MFL.Abs.TypeAnnotation
pTypeAnnotation = fmap snd . pTypeAnnotation_internal

pExp :: [Token] -> Err MFL.Abs.Exp
pExp = fmap snd . pExp_internal

pExp2 :: [Token] -> Err MFL.Abs.Exp
pExp2 = fmap snd . pExp2_internal

pExp5 :: [Token] -> Err MFL.Abs.Exp
pExp5 = fmap snd . pExp5_internal

pExp6 :: [Token] -> Err MFL.Abs.Exp
pExp6 = fmap snd . pExp6_internal

pExp7 :: [Token] -> Err MFL.Abs.Exp
pExp7 = fmap snd . pExp7_internal

pExp10 :: [Token] -> Err MFL.Abs.Exp
pExp10 = fmap snd . pExp10_internal

pExp14 :: [Token] -> Err MFL.Abs.Exp
pExp14 = fmap snd . pExp14_internal

pListExp :: [Token] -> Err [MFL.Abs.Exp]
pListExp = fmap snd . pListExp_internal

pConstantType :: [Token] -> Err MFL.Abs.ConstantType
pConstantType = fmap snd . pConstantType_internal
}

