-- File generated by the BNF Converter (bnfc 2.9.4).

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language MFL.

module MFL.Abs where

import Prelude (Char, Double, String)
import qualified Prelude as C
  ( Eq, Ord, Show, Read
  , Functor, Foldable, Traversable
  , Int, Maybe(..)
  )

import qualified Data.Text
import qualified Data.Data    as C (Data, Typeable)
import qualified GHC.Generics as C (Generic)

type SCPL = SCPL' BNFC'Position
data SCPL' a = SCPLPROG a [Defn' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Defn = Defn' BNFC'Position
data Defn' a = DEFN a PIdent (Stmt' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Stmt = Stmt' BNFC'Position
data Stmt' a
    = CASESTMT a (Exp' a) [CaseTerm' a]
    | IFSTMT a (Exp' a) (Stmt' a) (Stmt' a)
    | BARESTMT a (Exp' a)
    | ELet a (Let' a) (LetInStmt' a) (Stmt' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Let = Let' BNFC'Position
data Let' a = LET a | LRec a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type CaseTerm = CaseTerm' BNFC'Position
data CaseTerm' a = CASE_STMT a (CasePattern' a) (Stmt' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type LetInStmt = LetInStmt' BNFC'Position
data LetInStmt' a = LET_IN_STMT a PIdent (Exp' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Type = Type' BNFC'Position
data Type' a
    = TYPEARROW a (TypeN' a) (Type' a) | TYPENext a (TypeN' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type TypeN = TypeN' BNFC'Position
data TypeN' a
    = TYPEUNIT a TokUnit
    | TYPECONST_VAR a UIdent
    | TYPELIST a (Type' a)
    | TYPEPROD a [Type' a]
    | TYPEBRACKET a (Type' a)
    | CONST_TYPE a (ConstantType' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type CasePattern = CasePattern' BNFC'Position
data CasePattern' a = TRUE_PATTERN a | FALSE_PATTERN a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Exp = Exp' BNFC'Position
data Exp' a
    = EInt a PInteger
    | ETrue a
    | EFalse a
    | EVar a PIdent
    | EString a String
    | EList a [Exp' a]
    | ECall a PIdent [Exp' a]
    | ENeg a (Exp' a)
    | CONSTERM a (Exp' a) (Exp' a)
    | EAPPEND a (Exp' a) (Exp' a)
    | EMul a (Exp' a) (Exp' a)
    | EDiv a (Exp' a) (Exp' a)
    | EAdd a (Exp' a) (Exp' a)
    | ESub a (Exp' a) (Exp' a)
    | ELt a (Exp' a) (Exp' a)
    | EGt a (Exp' a) (Exp' a)
    | ELEq a (Exp' a) (Exp' a)
    | EGEq a (Exp' a) (Exp' a)
    | EEq a (Exp' a) (Exp' a)
    | ENEq a (Exp' a) (Exp' a)
    | EAnd a (Exp' a) (Exp' a)
    | EOr a (Exp' a) (Exp' a)
    | ELambda a [PIdent] (Stmt' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type TypeAnnotation = TypeAnnotation' BNFC'Position
data TypeAnnotation' a
    = TYPEANNOTATION a (Type' a) | TYPEANNOTATION_EMPTY a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type ConstantType = ConstantType' BNFC'Position
data ConstantType' a
    = INTEGER a PInteger
    | STRING a String
    | CHAR a Char
    | DOUBLE a Double
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

newtype TokUnit = TokUnit ((C.Int, C.Int), Data.Text.Text)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

newtype UIdent = UIdent ((C.Int, C.Int), Data.Text.Text)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

newtype PIdent = PIdent ((C.Int, C.Int), Data.Text.Text)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

newtype PInteger = PInteger ((C.Int, C.Int), Data.Text.Text)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic)

-- | Start position (line, column) of something.

type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.

class HasPosition a where
  hasPosition :: a -> BNFC'Position

instance HasPosition SCPL where
  hasPosition = \case
    SCPLPROG p _ -> p

instance HasPosition Defn where
  hasPosition = \case
    DEFN p _ _ -> p

instance HasPosition Stmt where
  hasPosition = \case
    CASESTMT p _ _ -> p
    IFSTMT p _ _ _ -> p
    BARESTMT p _ -> p
    ELet p _ _ _ -> p

instance HasPosition Let where
  hasPosition = \case
    LET p -> p
    LRec p -> p

instance HasPosition CaseTerm where
  hasPosition = \case
    CASE_STMT p _ _ -> p

instance HasPosition LetInStmt where
  hasPosition = \case
    LET_IN_STMT p _ _ -> p

instance HasPosition Type where
  hasPosition = \case
    TYPEARROW p _ _ -> p
    TYPENext p _ -> p

instance HasPosition TypeN where
  hasPosition = \case
    TYPEUNIT p _ -> p
    TYPECONST_VAR p _ -> p
    TYPELIST p _ -> p
    TYPEPROD p _ -> p
    TYPEBRACKET p _ -> p
    CONST_TYPE p _ -> p

instance HasPosition CasePattern where
  hasPosition = \case
    TRUE_PATTERN p -> p
    FALSE_PATTERN p -> p

instance HasPosition Exp where
  hasPosition = \case
    EInt p _ -> p
    ETrue p -> p
    EFalse p -> p
    EVar p _ -> p
    EString p _ -> p
    EList p _ -> p
    ECall p _ _ -> p
    ENeg p _ -> p
    CONSTERM p _ _ -> p
    EAPPEND p _ _ -> p
    EMul p _ _ -> p
    EDiv p _ _ -> p
    EAdd p _ _ -> p
    ESub p _ _ -> p
    ELt p _ _ -> p
    EGt p _ _ -> p
    ELEq p _ _ -> p
    EGEq p _ _ -> p
    EEq p _ _ -> p
    ENEq p _ _ -> p
    EAnd p _ _ -> p
    EOr p _ _ -> p
    ELambda p _ _ -> p

instance HasPosition TypeAnnotation where
  hasPosition = \case
    TYPEANNOTATION p _ -> p
    TYPEANNOTATION_EMPTY p -> p

instance HasPosition ConstantType where
  hasPosition = \case
    INTEGER p _ -> p
    STRING p _ -> p
    CHAR p _ -> p
    DOUBLE p _ -> p

instance HasPosition TokUnit where
  hasPosition (TokUnit (p, _)) = C.Just p

instance HasPosition UIdent where
  hasPosition (UIdent (p, _)) = C.Just p

instance HasPosition PIdent where
  hasPosition (PIdent (p, _)) = C.Just p

instance HasPosition PInteger where
  hasPosition (PInteger (p, _)) = C.Just p

