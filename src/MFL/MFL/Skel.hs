-- File generated by the BNF Converter (bnfc 2.9.4).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module MFL.Skel where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified MFL.Abs

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transTokUnit :: MFL.Abs.TokUnit -> Result
transTokUnit x = case x of
  MFL.Abs.TokUnit string -> failure x

transUIdent :: MFL.Abs.UIdent -> Result
transUIdent x = case x of
  MFL.Abs.UIdent string -> failure x

transPIdent :: MFL.Abs.PIdent -> Result
transPIdent x = case x of
  MFL.Abs.PIdent string -> failure x

transPInteger :: MFL.Abs.PInteger -> Result
transPInteger x = case x of
  MFL.Abs.PInteger string -> failure x

transSCPL :: Show a => MFL.Abs.SCPL' a -> Result
transSCPL x = case x of
  MFL.Abs.SCPLPROG _ defns -> failure x

transDefn :: Show a => MFL.Abs.Defn' a -> Result
transDefn x = case x of
  MFL.Abs.DEFN _ pident stmt -> failure x

transStmt :: Show a => MFL.Abs.Stmt' a -> Result
transStmt x = case x of
  MFL.Abs.CASESTMT _ exp caseterms -> failure x
  MFL.Abs.IFSTMT _ exp stmt1 stmt2 -> failure x
  MFL.Abs.BARESTMT _ exp -> failure x
  MFL.Abs.ELet _ let_ letinstmt stmt -> failure x

transLet :: Show a => MFL.Abs.Let' a -> Result
transLet x = case x of
  MFL.Abs.LET _ -> failure x
  MFL.Abs.LRec _ -> failure x

transCaseTerm :: Show a => MFL.Abs.CaseTerm' a -> Result
transCaseTerm x = case x of
  MFL.Abs.CASE_STMT _ casepattern stmt -> failure x

transLetInStmt :: Show a => MFL.Abs.LetInStmt' a -> Result
transLetInStmt x = case x of
  MFL.Abs.LET_IN_STMT _ pident exp -> failure x

transType :: Show a => MFL.Abs.Type' a -> Result
transType x = case x of
  MFL.Abs.TYPEARROW _ typen type_ -> failure x
  MFL.Abs.TYPENext _ typen -> failure x

transTypeN :: Show a => MFL.Abs.TypeN' a -> Result
transTypeN x = case x of
  MFL.Abs.TYPEUNIT _ tokunit -> failure x
  MFL.Abs.TYPECONST_VAR _ uident -> failure x
  MFL.Abs.TYPELIST _ type_ -> failure x
  MFL.Abs.TYPEPROD _ types -> failure x
  MFL.Abs.TYPEBRACKET _ type_ -> failure x
  MFL.Abs.CONST_TYPE _ constanttype -> failure x

transCasePattern :: Show a => MFL.Abs.CasePattern' a -> Result
transCasePattern x = case x of
  MFL.Abs.TRUE_PATTERN _ -> failure x
  MFL.Abs.FALSE_PATTERN _ -> failure x

transExp :: Show a => MFL.Abs.Exp' a -> Result
transExp x = case x of
  MFL.Abs.EInt _ pinteger -> failure x
  MFL.Abs.ETrue _ -> failure x
  MFL.Abs.EFalse _ -> failure x
  MFL.Abs.EVar _ pident -> failure x
  MFL.Abs.EString _ string -> failure x
  MFL.Abs.EList _ exps -> failure x
  MFL.Abs.ECall _ pident exps -> failure x
  MFL.Abs.ENeg _ exp -> failure x
  MFL.Abs.CONSTERM _ exp1 exp2 -> failure x
  MFL.Abs.EAPPEND _ exp1 exp2 -> failure x
  MFL.Abs.EMul _ exp1 exp2 -> failure x
  MFL.Abs.EDiv _ exp1 exp2 -> failure x
  MFL.Abs.EAdd _ exp1 exp2 -> failure x
  MFL.Abs.ESub _ exp1 exp2 -> failure x
  MFL.Abs.ELt _ exp1 exp2 -> failure x
  MFL.Abs.EGt _ exp1 exp2 -> failure x
  MFL.Abs.ELEq _ exp1 exp2 -> failure x
  MFL.Abs.EGEq _ exp1 exp2 -> failure x
  MFL.Abs.EEq _ exp1 exp2 -> failure x
  MFL.Abs.ENEq _ exp1 exp2 -> failure x
  MFL.Abs.EAnd _ exp1 exp2 -> failure x
  MFL.Abs.EOr _ exp1 exp2 -> failure x
  MFL.Abs.ELambda _ pidents stmt -> failure x

transTypeAnnotation :: Show a => MFL.Abs.TypeAnnotation' a -> Result
transTypeAnnotation x = case x of
  MFL.Abs.TYPEANNOTATION _ type_ -> failure x
  MFL.Abs.TYPEANNOTATION_EMPTY _ -> failure x

transConstantType :: Show a => MFL.Abs.ConstantType' a -> Result
transConstantType x = case x of
  MFL.Abs.INTEGER _ pinteger -> failure x
  MFL.Abs.STRING _ string -> failure x
  MFL.Abs.CHAR _ char -> failure x
  MFL.Abs.DOUBLE _ double -> failure x
